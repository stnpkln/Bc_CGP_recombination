<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>genome API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>genome</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from constants.operations import operations, op_inputs, op_functions
from utils import get_last_possible_input_index, get_output_gene_indexes
from typing import List
import numpy as np
from sklearn.metrics import mean_squared_error
from copy import deepcopy
from math import floor

mutation_rate = 0.1

def get_active_gene_indexes(genome: List[List[int]], output_gene_indexes: List[int]) -&gt; List[int]:
    &#39;&#39;&#39;[summary]
    Returns indexes of active genes in genome
    ### Parameters
    1. genome: List[List[int]]
        - genome to search active genes in
    2. output_gene_indexes: List[int]
        - list of indexes of output genes

    ### Returns
    List[int]
        - list of indexes of active genes in genome
    &#39;&#39;&#39;
    active_genes_indexes = []
    added_to_active_flag = [False] * len(genome) # flag for each gene if it was added to active genes

    found_new_gene = True
    gene_indexes_to_search = output_gene_indexes.copy()
    while (found_new_gene):
        new_indexes_to_search = []
        for gene_index_to_search in gene_indexes_to_search:
            gene = genome[gene_index_to_search]
            gene_operation = gene[0]

            # in case of input gene, skip it
            if (gene_operation == -1):
                continue

            # add the gene we are working with to active genes
            active_genes_indexes.append(gene_index_to_search)

            # in case of output gene, save it to active genes, and continue
            if (gene_operation == -2):
                input_gene_index = gene[1]
                if (not added_to_active_flag[input_gene_index]):
                    # mark the input of this gene as active, and add it to active genes
                    added_to_active_flag[input_gene_index] = True
                    new_indexes_to_search.append(input_gene_index)
                continue

            # function genes
            for i in range(1, 1 + op_inputs[operations[gene_operation]]): # for each input that the operation of this gene has
                input_gene_index = gene[i] # in case of output gene, use only the first input
                if (not added_to_active_flag[input_gene_index]):
                    # mark the input of this gene as active, and add it to genes to search next
                    added_to_active_flag[input_gene_index] = True
                    new_indexes_to_search.append(input_gene_index)

        found_new_gene = len(new_indexes_to_search) != 0 # if there are no new genes to search, stop the loop
        gene_indexes_to_search = new_indexes_to_search # reassign the genes to search

    return active_genes_indexes

def genome_output(genome: List[List[int]], input_matrix: np.ndarray[np.ndarray[int | float]]) -&gt; np.ndarray[float | int]:
    &#39;&#39;&#39;[summary]
    ### Parameters
    1. genome: List[List[int]]
        - genome to calculate output for
    2. input_matrix: np.ndarray[np.ndarray[int | float]]
        - list of input values to calculate output for
        - each list of input values is one input

    ### Returns
    np.ndarray
        - output of genome for given input values
        - works with only one output gene (TODO if necessary)
    &#39;&#39;&#39;
    output_gene_indexes = get_output_gene_indexes(genome)
    active_gene_indexes = get_active_gene_indexes(genome, output_gene_indexes)
    n_input_nodes = len(input_matrix) # gen number of input nodes, base on parameter input_matrix
    nrows = len(active_gene_indexes) + n_input_nodes # number of rows in matrix
    ncols = len(input_matrix[0]) # number of columns in matrix

    # mapping from gene index to matrix index, so we can use gene indexes to access the matrix, and the matrix can be only as big as the number of active nodes
    gene_to_matrix_mapping = {key: value for key, value in zip(active_gene_indexes[::-1], range(n_input_nodes, nrows))}

    matrix = np.full((nrows, ncols), 0.0)

    # fill the matrix with input values
    for i in range(n_input_nodes):
        matrix[i] = input_matrix[i]
        gene_to_matrix_mapping[i] = i

    # fill the matrix with output of genes
    for i in range(len(active_gene_indexes)):
        for gene_index in active_gene_indexes:
            gene = genome[gene_index]
            gene_operation = gene[0]

            # in case of input gene, skip it
            if (gene_operation == -1):
                continue

            # in case of output gene, copy the input gene output
            if (gene_operation == -2):
                last_function_gene_index = gene[1]
                matrix[gene_to_matrix_mapping[gene_index]] = matrix[gene_to_matrix_mapping[last_function_gene_index]]
                continue

            # function genes
            n_of_op_inputs = op_inputs[operations[gene_operation]]
            op_function = op_functions[operations[gene_operation]]

            if n_of_op_inputs == 1:
                first_input = matrix[gene_to_matrix_mapping[gene[1]]]
                matrix[gene_to_matrix_mapping[gene_index]] = op_function(first_input)
            elif n_of_op_inputs == 2:
                first_input = matrix[gene_to_matrix_mapping[gene[1]]]
                second_input = matrix[gene_to_matrix_mapping[gene[2]]]
                matrix[gene_to_matrix_mapping[gene_index]] = op_function(first_input, second_input) # calculate the output of the gene

    # return the last column (output column) of the matrix
    return matrix[-1]

def evaluate_fitness(genome: List[List[int]], input_matrix: np.ndarray[np.ndarray[int | float]], wanted_output: np.ndarray[float | int]) -&gt; float:
    &#39;&#39;&#39;[summary]
    Returns fitness of genome for given input values and wanted output.
    Fitness value is calculated as mean squared error between wanted output and output of genome for given input values.
    ### Parameters
    1. genome: List[List[int]]
        - genome to calculate fitness for
    2. input_matrix: np.ndarray[np.ndarray[int | float]]
        - list of input values to calculate output for
        - each list of input values is one input
    3. wanted_output: np.ndarray[float | int]
        - list of wanted output values
    ### Returns
    float
        - fitness of genome for given input values and wanted output
        - value &gt;= 0.0
    &#39;&#39;&#39;
    output = genome_output(genome, input_matrix)
    mse = mean_squared_error(wanted_output, output)
    if (mse &lt; 0):
        raise ValueError(&#34;overflow, mean squared error is negative, something went wrong with the fitness calculation&#34;)
    return mse

def mutate_individual(target: List[List[int]], ncolumns: int, nrows: int) -&gt; List[List[int]]:
    &#39;&#39;&#39;[summary]
    Returns mutated individual, without changing the original
    ### Parameters
    1. target: List[List[int]]
        - individual to mutate
    2. ncolumns: int
        - number of columns in the matrix of genes
    3. nrows: int
        - number of rows in the matrix of genes
    ### Returns
    List[List[int]]
        - mutated individual
    &#39;&#39;&#39;
    # deep copy the target, so we don&#39;t change the original
    individual = deepcopy(target)
    genome_length = len(individual)
    n_of_genes_to_mutate = floor(genome_length * mutation_rate + 1)

    for i in range(n_of_genes_to_mutate):
        success = False
        mutated_gene = []

        # find a gene that can be mutated
        while(not success):
            gene_index_to_mutate = np.random.randint(genome_length)
            gene = individual[gene_index_to_mutate]
            mutated_gene, success = mutate_gene(gene, gene_index_to_mutate, ncolumns, nrows)

        individual[gene_index_to_mutate] = mutated_gene

    return individual

def mutate_gene(gene: List[int], gene_index: int, ncolumns: int, nrows: int) -&gt; tuple[List[int], bool]:
    &#39;&#39;&#39;[summary]
    Returns mutated gene (may mutate the original)
    ### Parameters
    1. gene: List[int]
        - gene to mutate
    2. gene_index: int
        - index of the gene in the genome
    3. ncolumns: int
        - number of columns in the matrix of genes
    4. nrows: int
        - number of rows in the matrix of genes
    ### Returns
    List[int]
        - mutated gene
    bool
        - True if gene was successfully mutated, False otherwise
    Raises
    ------
    - Exception
        - if last_possible_input_index is 0, meaning that an internal error occured
    ### 
    &#39;&#39;&#39;
    allele_to_mutate = np.random.randint(0, len(gene))

    if gene[allele_to_mutate] == -1 or gene[allele_to_mutate] == -2:
        return gene, False

    mutation_to_be_done = True
    while(mutation_to_be_done):
        original = gene[allele_to_mutate]

        # if the gene is an operation, mutate it to another operation
        if allele_to_mutate == 0:
            mutated = np.random.randint(0, len(operations))
        # if the gene is an input, mutate it to another (correct) input
        else:
            last_possible_input_index = get_last_possible_input_index(ncolumns, nrows, gene_index)
            if (last_possible_input_index &lt;= 0):
                raise Exception(f&#34;last_possible_input_index is: {last_possible_input_index}, gene_index is: {gene_index}, ncolumns is: {ncolumns}, nrows is: {nrows}&#34;)
            elif (last_possible_input_index == 1):
                return gene, False # impossible to mutate input, if there is only one option available

            mutated = np.random.randint(0, last_possible_input_index)

        # if the gene was successfully mutated, stop the loop
        if original != mutated:
            gene[allele_to_mutate] = mutated
            mutation_to_be_done = False

    return gene, True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="genome.evaluate_fitness"><code class="name flex">
<span>def <span class="ident">evaluate_fitness</span></span>(<span>genome: List[List[int]], input_matrix: numpy.ndarray[numpy.ndarray[int | float]], wanted_output: numpy.ndarray[float | int]) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Returns fitness of genome for given input values and wanted output.
Fitness value is calculated as mean squared error between wanted output and output of genome for given input values.</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>genome: List[List[int]]<ul>
<li>genome to calculate fitness for</li>
</ul>
</li>
<li>input_matrix: np.ndarray[np.ndarray[int | float]]<ul>
<li>list of input values to calculate output for</li>
<li>each list of input values is one input</li>
</ul>
</li>
<li>wanted_output: np.ndarray[float | int]<ul>
<li>list of wanted output values</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>float
- fitness of genome for given input values and wanted output
- value &gt;= 0.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_fitness(genome: List[List[int]], input_matrix: np.ndarray[np.ndarray[int | float]], wanted_output: np.ndarray[float | int]) -&gt; float:
    &#39;&#39;&#39;[summary]
    Returns fitness of genome for given input values and wanted output.
    Fitness value is calculated as mean squared error between wanted output and output of genome for given input values.
    ### Parameters
    1. genome: List[List[int]]
        - genome to calculate fitness for
    2. input_matrix: np.ndarray[np.ndarray[int | float]]
        - list of input values to calculate output for
        - each list of input values is one input
    3. wanted_output: np.ndarray[float | int]
        - list of wanted output values
    ### Returns
    float
        - fitness of genome for given input values and wanted output
        - value &gt;= 0.0
    &#39;&#39;&#39;
    output = genome_output(genome, input_matrix)
    mse = mean_squared_error(wanted_output, output)
    if (mse &lt; 0):
        raise ValueError(&#34;overflow, mean squared error is negative, something went wrong with the fitness calculation&#34;)
    return mse</code></pre>
</details>
</dd>
<dt id="genome.genome_output"><code class="name flex">
<span>def <span class="ident">genome_output</span></span>(<span>genome: List[List[int]], input_matrix: numpy.ndarray[numpy.ndarray[int | float]]) ‑> numpy.ndarray[float | int]</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>genome: List[List[int]]<ul>
<li>genome to calculate output for</li>
</ul>
</li>
<li>input_matrix: np.ndarray[np.ndarray[int | float]]<ul>
<li>list of input values to calculate output for</li>
<li>each list of input values is one input</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>np.ndarray
- output of genome for given input values
- works with only one output gene (TODO if necessary)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def genome_output(genome: List[List[int]], input_matrix: np.ndarray[np.ndarray[int | float]]) -&gt; np.ndarray[float | int]:
    &#39;&#39;&#39;[summary]
    ### Parameters
    1. genome: List[List[int]]
        - genome to calculate output for
    2. input_matrix: np.ndarray[np.ndarray[int | float]]
        - list of input values to calculate output for
        - each list of input values is one input

    ### Returns
    np.ndarray
        - output of genome for given input values
        - works with only one output gene (TODO if necessary)
    &#39;&#39;&#39;
    output_gene_indexes = get_output_gene_indexes(genome)
    active_gene_indexes = get_active_gene_indexes(genome, output_gene_indexes)
    n_input_nodes = len(input_matrix) # gen number of input nodes, base on parameter input_matrix
    nrows = len(active_gene_indexes) + n_input_nodes # number of rows in matrix
    ncols = len(input_matrix[0]) # number of columns in matrix

    # mapping from gene index to matrix index, so we can use gene indexes to access the matrix, and the matrix can be only as big as the number of active nodes
    gene_to_matrix_mapping = {key: value for key, value in zip(active_gene_indexes[::-1], range(n_input_nodes, nrows))}

    matrix = np.full((nrows, ncols), 0.0)

    # fill the matrix with input values
    for i in range(n_input_nodes):
        matrix[i] = input_matrix[i]
        gene_to_matrix_mapping[i] = i

    # fill the matrix with output of genes
    for i in range(len(active_gene_indexes)):
        for gene_index in active_gene_indexes:
            gene = genome[gene_index]
            gene_operation = gene[0]

            # in case of input gene, skip it
            if (gene_operation == -1):
                continue

            # in case of output gene, copy the input gene output
            if (gene_operation == -2):
                last_function_gene_index = gene[1]
                matrix[gene_to_matrix_mapping[gene_index]] = matrix[gene_to_matrix_mapping[last_function_gene_index]]
                continue

            # function genes
            n_of_op_inputs = op_inputs[operations[gene_operation]]
            op_function = op_functions[operations[gene_operation]]

            if n_of_op_inputs == 1:
                first_input = matrix[gene_to_matrix_mapping[gene[1]]]
                matrix[gene_to_matrix_mapping[gene_index]] = op_function(first_input)
            elif n_of_op_inputs == 2:
                first_input = matrix[gene_to_matrix_mapping[gene[1]]]
                second_input = matrix[gene_to_matrix_mapping[gene[2]]]
                matrix[gene_to_matrix_mapping[gene_index]] = op_function(first_input, second_input) # calculate the output of the gene

    # return the last column (output column) of the matrix
    return matrix[-1]</code></pre>
</details>
</dd>
<dt id="genome.get_active_gene_indexes"><code class="name flex">
<span>def <span class="ident">get_active_gene_indexes</span></span>(<span>genome: List[List[int]], output_gene_indexes: List[int]) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Returns indexes of active genes in genome</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>genome: List[List[int]]<ul>
<li>genome to search active genes in</li>
</ul>
</li>
<li>output_gene_indexes: List[int]<ul>
<li>list of indexes of output genes</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>List[int]
- list of indexes of active genes in genome</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_active_gene_indexes(genome: List[List[int]], output_gene_indexes: List[int]) -&gt; List[int]:
    &#39;&#39;&#39;[summary]
    Returns indexes of active genes in genome
    ### Parameters
    1. genome: List[List[int]]
        - genome to search active genes in
    2. output_gene_indexes: List[int]
        - list of indexes of output genes

    ### Returns
    List[int]
        - list of indexes of active genes in genome
    &#39;&#39;&#39;
    active_genes_indexes = []
    added_to_active_flag = [False] * len(genome) # flag for each gene if it was added to active genes

    found_new_gene = True
    gene_indexes_to_search = output_gene_indexes.copy()
    while (found_new_gene):
        new_indexes_to_search = []
        for gene_index_to_search in gene_indexes_to_search:
            gene = genome[gene_index_to_search]
            gene_operation = gene[0]

            # in case of input gene, skip it
            if (gene_operation == -1):
                continue

            # add the gene we are working with to active genes
            active_genes_indexes.append(gene_index_to_search)

            # in case of output gene, save it to active genes, and continue
            if (gene_operation == -2):
                input_gene_index = gene[1]
                if (not added_to_active_flag[input_gene_index]):
                    # mark the input of this gene as active, and add it to active genes
                    added_to_active_flag[input_gene_index] = True
                    new_indexes_to_search.append(input_gene_index)
                continue

            # function genes
            for i in range(1, 1 + op_inputs[operations[gene_operation]]): # for each input that the operation of this gene has
                input_gene_index = gene[i] # in case of output gene, use only the first input
                if (not added_to_active_flag[input_gene_index]):
                    # mark the input of this gene as active, and add it to genes to search next
                    added_to_active_flag[input_gene_index] = True
                    new_indexes_to_search.append(input_gene_index)

        found_new_gene = len(new_indexes_to_search) != 0 # if there are no new genes to search, stop the loop
        gene_indexes_to_search = new_indexes_to_search # reassign the genes to search

    return active_genes_indexes</code></pre>
</details>
</dd>
<dt id="genome.mutate_gene"><code class="name flex">
<span>def <span class="ident">mutate_gene</span></span>(<span>gene: List[int], gene_index: int, ncolumns: int, nrows: int) ‑> tuple[typing.List[int], bool]</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Returns mutated gene (may mutate the original)</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>gene: List[int]<ul>
<li>gene to mutate</li>
</ul>
</li>
<li>gene_index: int<ul>
<li>index of the gene in the genome</li>
</ul>
</li>
<li>ncolumns: int<ul>
<li>number of columns in the matrix of genes</li>
</ul>
</li>
<li>nrows: int<ul>
<li>number of rows in the matrix of genes</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>List[int]
- mutated gene
bool
- True if gene was successfully mutated, False otherwise
Raises</p>
<hr>
<ul>
<li>Exception<ul>
<li>if last_possible_input_index is 0, meaning that an internal error occured</li>
</ul>
</li>
</ul>
<h3 id="_1"></h3></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutate_gene(gene: List[int], gene_index: int, ncolumns: int, nrows: int) -&gt; tuple[List[int], bool]:
    &#39;&#39;&#39;[summary]
    Returns mutated gene (may mutate the original)
    ### Parameters
    1. gene: List[int]
        - gene to mutate
    2. gene_index: int
        - index of the gene in the genome
    3. ncolumns: int
        - number of columns in the matrix of genes
    4. nrows: int
        - number of rows in the matrix of genes
    ### Returns
    List[int]
        - mutated gene
    bool
        - True if gene was successfully mutated, False otherwise
    Raises
    ------
    - Exception
        - if last_possible_input_index is 0, meaning that an internal error occured
    ### 
    &#39;&#39;&#39;
    allele_to_mutate = np.random.randint(0, len(gene))

    if gene[allele_to_mutate] == -1 or gene[allele_to_mutate] == -2:
        return gene, False

    mutation_to_be_done = True
    while(mutation_to_be_done):
        original = gene[allele_to_mutate]

        # if the gene is an operation, mutate it to another operation
        if allele_to_mutate == 0:
            mutated = np.random.randint(0, len(operations))
        # if the gene is an input, mutate it to another (correct) input
        else:
            last_possible_input_index = get_last_possible_input_index(ncolumns, nrows, gene_index)
            if (last_possible_input_index &lt;= 0):
                raise Exception(f&#34;last_possible_input_index is: {last_possible_input_index}, gene_index is: {gene_index}, ncolumns is: {ncolumns}, nrows is: {nrows}&#34;)
            elif (last_possible_input_index == 1):
                return gene, False # impossible to mutate input, if there is only one option available

            mutated = np.random.randint(0, last_possible_input_index)

        # if the gene was successfully mutated, stop the loop
        if original != mutated:
            gene[allele_to_mutate] = mutated
            mutation_to_be_done = False

    return gene, True</code></pre>
</details>
</dd>
<dt id="genome.mutate_individual"><code class="name flex">
<span>def <span class="ident">mutate_individual</span></span>(<span>target: List[List[int]], ncolumns: int, nrows: int) ‑> List[List[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Returns mutated individual, without changing the original</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>target: List[List[int]]<ul>
<li>individual to mutate</li>
</ul>
</li>
<li>ncolumns: int<ul>
<li>number of columns in the matrix of genes</li>
</ul>
</li>
<li>nrows: int<ul>
<li>number of rows in the matrix of genes</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>List[List[int]]
- mutated individual</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutate_individual(target: List[List[int]], ncolumns: int, nrows: int) -&gt; List[List[int]]:
    &#39;&#39;&#39;[summary]
    Returns mutated individual, without changing the original
    ### Parameters
    1. target: List[List[int]]
        - individual to mutate
    2. ncolumns: int
        - number of columns in the matrix of genes
    3. nrows: int
        - number of rows in the matrix of genes
    ### Returns
    List[List[int]]
        - mutated individual
    &#39;&#39;&#39;
    # deep copy the target, so we don&#39;t change the original
    individual = deepcopy(target)
    genome_length = len(individual)
    n_of_genes_to_mutate = floor(genome_length * mutation_rate + 1)

    for i in range(n_of_genes_to_mutate):
        success = False
        mutated_gene = []

        # find a gene that can be mutated
        while(not success):
            gene_index_to_mutate = np.random.randint(genome_length)
            gene = individual[gene_index_to_mutate]
            mutated_gene, success = mutate_gene(gene, gene_index_to_mutate, ncolumns, nrows)

        individual[gene_index_to_mutate] = mutated_gene

    return individual</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="genome.evaluate_fitness" href="#genome.evaluate_fitness">evaluate_fitness</a></code></li>
<li><code><a title="genome.genome_output" href="#genome.genome_output">genome_output</a></code></li>
<li><code><a title="genome.get_active_gene_indexes" href="#genome.get_active_gene_indexes">get_active_gene_indexes</a></code></li>
<li><code><a title="genome.mutate_gene" href="#genome.mutate_gene">mutate_gene</a></code></li>
<li><code><a title="genome.mutate_individual" href="#genome.mutate_individual">mutate_individual</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>