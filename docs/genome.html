<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>genome API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>genome</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from constants.operations import operations, op_inputs, op_functions
from utils import get_active_gene_indexes, get_last_possible_input_index, get_number_of_op_inputs, get_output_gene_indexes, is_input_gene, is_output_gene, random_bool
import numpy as np
from sklearn.metrics import mean_squared_error
from copy import deepcopy
from math import floor

def genome_output(genome, active_gene_indexes, input_matrix):
    &#39;&#39;&#39;[summary]
    ### Parameters
    1. genome
        - genome to calculate output for
    2. input_matrix
        - list of input values to calculate output for
        - each list of input values is one input

    ### Returns
    np.ndarray
        - output of genome for given input values
        - works with only one output gene (TODO if necessary)
    &#39;&#39;&#39;
    n_input_nodes = len(input_matrix) # gen number of input nodes, base on parameter input_matrix
    nrows = len(active_gene_indexes) + n_input_nodes # number of rows in matrix
    ncols = len(input_matrix[0]) # number of columns in matrix

    # mapping from gene index to matrix index, so we can use gene indexes to access the matrix, and the matrix can be only as big as the number of active nodes
    gene_to_matrix_mapping = {key: value for key, value in zip(active_gene_indexes[::-1], range(n_input_nodes, nrows))}

    matrix = np.full((nrows, ncols), 0.0)

    # fill the matrix with input values
    for i in range(n_input_nodes):
        matrix[i] = input_matrix[i]
        gene_to_matrix_mapping[i] = i

    # fill the matrix with output of genes
    for i in range(len(active_gene_indexes)):
        for gene_index in active_gene_indexes:
            gene = genome[gene_index]
            gene_operation = gene[0]

            # in case of input gene, skip it
            if (gene_operation == -1):
                continue

            # in case of output gene, copy the input gene output
            if (gene_operation == -2):
                last_function_gene_index = gene[1]
                matrix[gene_to_matrix_mapping[gene_index]] = matrix[gene_to_matrix_mapping[last_function_gene_index]]
                continue

            # function genes
            n_of_op_inputs = op_inputs[operations[gene_operation]]
            op_function = op_functions[operations[gene_operation]]

            if n_of_op_inputs == 1:
                first_input = matrix[gene_to_matrix_mapping[gene[1]]]
                matrix[gene_to_matrix_mapping[gene_index]] = op_function(first_input)
            elif n_of_op_inputs == 2:
                first_input = matrix[gene_to_matrix_mapping[gene[1]]]
                second_input = matrix[gene_to_matrix_mapping[gene[2]]]
                matrix[gene_to_matrix_mapping[gene_index]] = op_function(first_input, second_input) # calculate the output of the gene

    # return the last column (output column) of the matrix
    return matrix[-1]

def evaluate_fitness(genome, genome_active_path_indexes, input_matrix, wanted_output, max_difference=0.01):
    &#39;&#39;&#39;[summary]
    Returns fitness of genome for given input values and wanted output.
    Fitness value is calculated as mean absolute error between wanted output and output of genome for given input values.
    ### Parameters
    1. genome
        - genome to calculate fitness for
    2. input_matrix
        - list of input values to calculate output for
        - each list of input values is one input
    3. wanted_output
        - list of wanted output values
    ### Returns
    float
        - fitness of genome for given input values and wanted output
        - value &gt;= 0.0
    &#39;&#39;&#39;
    output = genome_output(genome, genome_active_path_indexes, input_matrix)
    mae = np.absolute(np.subtract(wanted_output, output)).sum()
    if (mae &lt; 0):
        raise ValueError(&#34;overflow, mean squared error is negative, something went wrong with the fitness calculation&#34;)
    is_acceptable = is_acceptable_solution(output, wanted_output, max_difference)
    return mae, is_acceptable

def mutate_individual(target, ncolumns, nrows, mutation_rate):
    &#39;&#39;&#39;[summary]
    Returns mutated individual, without changing the original
    ### Parameters
    1. target
        - individual to mutate
    2. ncolumns
        - number of columns in the matrix of genes
    3. nrows
        - number of rows in the matrix of genes
    4. mutation_rate
        - mutation rate of the algorithm
    ### Returns
    List[List[int]]
        - mutated individual
    &#39;&#39;&#39;
    # deep copy the target, so we don&#39;t change the original
    individual = deepcopy(target)
    genome_length = len(individual)
    n_of_genes_to_mutate = floor(genome_length * mutation_rate + 1)

    for i in range(n_of_genes_to_mutate):
        success = False
        mutated_gene = []

        # find a gene that can be mutated
        while(not success):
            gene_index_to_mutate = np.random.randint(genome_length)
            gene = individual[gene_index_to_mutate]
            mutated_gene, success = mutate_gene(gene, gene_index_to_mutate, ncolumns, nrows)

        individual[gene_index_to_mutate] = mutated_gene

    return individual

def mutate_gene(gene, gene_index, ncolumns, nrows):
    &#39;&#39;&#39;[summary]
    Returns mutated gene (may mutate the original)
    ### Parameters
    1. gene
        - gene to mutate
    2. gene_index
        - index of the gene in the genome
    3. ncolumns
        - number of columns in the matrix of genes
    4. nrows
        - number of rows in the matrix of genes
    ### Returns
    List[int]
        - mutated gene
    bool
        - True if gene was successfully mutated, False otherwise
    Raises
    ------
    - Exception
        - if last_possible_input_index is 0, meaning that an internal error occured
    ### 
    &#39;&#39;&#39;
    allele_to_mutate = np.random.randint(0, len(gene))

    if gene[allele_to_mutate] == -1 or gene[allele_to_mutate] == -2:
        return gene, False

    mutation_to_be_done = True
    while(mutation_to_be_done):
        original = gene[allele_to_mutate]

        # if the gene is an operation, mutate it to another operation
        if allele_to_mutate == 0:
            mutated = np.random.randint(0, len(operations))
        # if the gene is an input, mutate it to another (correct) input
        else:
            last_possible_input_index = get_last_possible_input_index(ncolumns, nrows, gene_index)
            if (last_possible_input_index &lt;= 0):
                raise Exception(f&#34;last_possible_input_index is: {last_possible_input_index}, gene_index is: {gene_index}, ncolumns is: {ncolumns}, nrows is: {nrows}&#34;)
            elif (last_possible_input_index == 1):
                return gene, False # impossible to mutate input, if there is only one option available

            mutated = np.random.randint(0, last_possible_input_index)

        # if the gene was successfully mutated, stop the loop
        if original != mutated:
            # in case the mutation is changing the operation, prepare the inputs for the new operation
            if allele_to_mutate == 0:
                format_inputs_for_new_operation(gene, gene_index, mutated, nrows)
            gene[allele_to_mutate] = mutated
            mutation_to_be_done = False

    return gene, True

def active_gene_transplant(receiver, receiver_active_path, donor, donor_active_path, exchange_rate, nrows = 1):
    &#39;&#39;&#39;[summary]
    Returns child genome from two parent genomes using recombination 1
    ### Parameters
    1. donor
        - first parent genome
    2. receiver
        - second parent genome
    ### Returns
    List[List[int]]
        - child genome
    &#39;&#39;&#39;
    # deep copy the parents, so we don&#39;t change the original
    child = deepcopy(receiver)

    exchange_indexes = [gene for gene in donor_active_path if gene not in receiver_active_path and random_bool(exchange_rate)]
    for exchange_index in exchange_indexes:
        donor_gene = donor[exchange_index].copy()
        child[exchange_index] = donor_gene

    return child

def subgraph_exchange(receiver, receiver_active_path, donor, donor_active_path, exchange_rate, nrows):
    &#39;&#39;&#39;[summary]
    Returns child genome from two parent genomes using recombination 2
    ### Parameters
    1. parent1
        - first parent genome
    2. parent2
        - second parent genome
    ### Returns
    List[List[int]]
        - child genome
    &#39;&#39;&#39;

    # deep copy the parents, so we don&#39;t change the original
    child = deepcopy(receiver)

    possible_exchange_indexes = [gene for gene in receiver_active_path if gene in donor_active_path]
    exchange_index = np.random.choice(possible_exchange_indexes)

    receiver_flags = [False for _ in range(len(receiver))]
    exchange(receiver=child, receiver_flags=receiver_flags, receiver_index=exchange_index, donor=donor, donor_index=exchange_index, exchange_rate=exchange_rate, nrows=nrows)
    return child


def exchange(receiver, receiver_flags, receiver_index, donor, donor_index, exchange_rate, nrows):
    &#39;&#39;&#39;[summary]
    Recursively exchanges the genes between the receiver and the donor
    ### Parameters
    1. receiver
        - genome of the receiver
    2. receiver_flags
        - flags for each gene in receiver, if it was already exchanged
    3. receiver_index
        - index of the gene in the receiver
    4. donor
        - genome of the donor
    5. donor_index
        - index of the gene in the donor
    6. exchange_rate
        - exchange rate of the algorithm
    7. nrows
        - number of rows in the matrix of genes
    ### Returns
    None
    &#39;&#39;&#39;
    if receiver_flags[receiver_index]:
        return
    
    receiver_gene = receiver[receiver_index]
    donor_gene = donor[donor_index]
    if is_input_gene(receiver_gene) or is_input_gene(donor_gene):
        return
    
    if is_output_gene(receiver_gene):
        if is_output_gene(donor_gene):
            exchange(receiver=receiver,
                        receiver_flags=receiver_flags,
                        receiver_index=receiver_gene[1],
                        donor=donor,
                        donor_index=donor_gene[1],
                        exchange_rate=exchange_rate,
                        nrows=nrows)
            return
        else:
            raise Exception(&#34;output gene mismatch in subgraph exchange&#34;)
        
    next_receiver_genes = []
    next_donor_genes = []
    for i in range(1, len(receiver_gene)):
        if receiver_gene[i] != -1 and donor_gene[i] != -1 and random_bool(exchange_rate):
            next_receiver_genes.append(receiver_gene[i])
            next_donor_genes.append(donor_gene[i])
    
    format_inputs_for_new_operation(receiver[receiver_index], receiver_index, donor_gene[0], nrows)
    receiver_gene[0] = donor_gene[0]
    receiver_flags[receiver_index] = True

    for i in range(len(next_receiver_genes)):
        exchange(receiver=receiver,
                    receiver_flags=receiver_flags,
                    receiver_index=next_receiver_genes[i],
                    donor=donor,
                    donor_index=next_donor_genes[i],
                    exchange_rate=exchange_rate,
                    nrows=nrows)

def format_inputs_for_new_operation(gene, gene_index, new_operation, nrows):
    &#39;&#39;&#39;[summary]
    Prepares the given gene for a change of operation allele, by changing the inputs to match the new operation.
    Shortened inputs are set to -1, if a new input is needed, it is set to a random (in bounds) value.
    ### Parameters
    1. gene
        - gene to prepare inputs for
    2. gene_index
        - index of the gene to prepare in given genome
    3. operation
        - new operation to be inside gene
    4. nrows
        - number of rows in the matrix of genes
    &#39;&#39;&#39;
    ncolumns = len(gene) / nrows
    operation_inputs = get_number_of_op_inputs(new_operation)
    for input_number in range(1, len(gene)):
        if input_number &lt;= operation_inputs and gene[input_number] == -1:
            gene[input_number] = np.random.randint(get_last_possible_input_index(ncolumns, nrows, gene_index))
        elif input_number &gt; operation_inputs and gene[input_number] != -1:
            gene[input_number] = -1

def is_acceptable_solution(output, wanted_output, max_difference):
    &#39;&#39;&#39;[summary]
    Returns True if the difference between output and wanted_output is less than max_difference, False otherwise
    ### Parameters
    1. output
        - output to compare
    2. wanted_output
        - wanted output to compare
    3. max_difference
        - maximum difference between output and wanted_output
    ### Returns
    bool
        - True if the difference between output and wanted_output is less than max_difference, False otherwise
    &#39;&#39;&#39;
    return np.absolute(np.subtract(wanted_output, output)).max() &lt;= max_difference</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="genome.active_gene_transplant"><code class="name flex">
<span>def <span class="ident">active_gene_transplant</span></span>(<span>receiver, receiver_active_path, donor, donor_active_path, exchange_rate, nrows=1)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Returns child genome from two parent genomes using recombination 1</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>donor<ul>
<li>first parent genome</li>
</ul>
</li>
<li>receiver<ul>
<li>second parent genome</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>List[List[int]]
- child genome</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def active_gene_transplant(receiver, receiver_active_path, donor, donor_active_path, exchange_rate, nrows = 1):
    &#39;&#39;&#39;[summary]
    Returns child genome from two parent genomes using recombination 1
    ### Parameters
    1. donor
        - first parent genome
    2. receiver
        - second parent genome
    ### Returns
    List[List[int]]
        - child genome
    &#39;&#39;&#39;
    # deep copy the parents, so we don&#39;t change the original
    child = deepcopy(receiver)

    exchange_indexes = [gene for gene in donor_active_path if gene not in receiver_active_path and random_bool(exchange_rate)]
    for exchange_index in exchange_indexes:
        donor_gene = donor[exchange_index].copy()
        child[exchange_index] = donor_gene

    return child</code></pre>
</details>
</dd>
<dt id="genome.evaluate_fitness"><code class="name flex">
<span>def <span class="ident">evaluate_fitness</span></span>(<span>genome, genome_active_path_indexes, input_matrix, wanted_output, max_difference=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Returns fitness of genome for given input values and wanted output.
Fitness value is calculated as mean absolute error between wanted output and output of genome for given input values.</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>genome<ul>
<li>genome to calculate fitness for</li>
</ul>
</li>
<li>input_matrix<ul>
<li>list of input values to calculate output for</li>
<li>each list of input values is one input</li>
</ul>
</li>
<li>wanted_output<ul>
<li>list of wanted output values</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>float
- fitness of genome for given input values and wanted output
- value &gt;= 0.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_fitness(genome, genome_active_path_indexes, input_matrix, wanted_output, max_difference=0.01):
    &#39;&#39;&#39;[summary]
    Returns fitness of genome for given input values and wanted output.
    Fitness value is calculated as mean absolute error between wanted output and output of genome for given input values.
    ### Parameters
    1. genome
        - genome to calculate fitness for
    2. input_matrix
        - list of input values to calculate output for
        - each list of input values is one input
    3. wanted_output
        - list of wanted output values
    ### Returns
    float
        - fitness of genome for given input values and wanted output
        - value &gt;= 0.0
    &#39;&#39;&#39;
    output = genome_output(genome, genome_active_path_indexes, input_matrix)
    mae = np.absolute(np.subtract(wanted_output, output)).sum()
    if (mae &lt; 0):
        raise ValueError(&#34;overflow, mean squared error is negative, something went wrong with the fitness calculation&#34;)
    is_acceptable = is_acceptable_solution(output, wanted_output, max_difference)
    return mae, is_acceptable</code></pre>
</details>
</dd>
<dt id="genome.exchange"><code class="name flex">
<span>def <span class="ident">exchange</span></span>(<span>receiver, receiver_flags, receiver_index, donor, donor_index, exchange_rate, nrows)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Recursively exchanges the genes between the receiver and the donor</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>receiver<ul>
<li>genome of the receiver</li>
</ul>
</li>
<li>receiver_flags<ul>
<li>flags for each gene in receiver, if it was already exchanged</li>
</ul>
</li>
<li>receiver_index<ul>
<li>index of the gene in the receiver</li>
</ul>
</li>
<li>donor<ul>
<li>genome of the donor</li>
</ul>
</li>
<li>donor_index<ul>
<li>index of the gene in the donor</li>
</ul>
</li>
<li>exchange_rate<ul>
<li>exchange rate of the algorithm</li>
</ul>
</li>
<li>nrows<ul>
<li>number of rows in the matrix of genes</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exchange(receiver, receiver_flags, receiver_index, donor, donor_index, exchange_rate, nrows):
    &#39;&#39;&#39;[summary]
    Recursively exchanges the genes between the receiver and the donor
    ### Parameters
    1. receiver
        - genome of the receiver
    2. receiver_flags
        - flags for each gene in receiver, if it was already exchanged
    3. receiver_index
        - index of the gene in the receiver
    4. donor
        - genome of the donor
    5. donor_index
        - index of the gene in the donor
    6. exchange_rate
        - exchange rate of the algorithm
    7. nrows
        - number of rows in the matrix of genes
    ### Returns
    None
    &#39;&#39;&#39;
    if receiver_flags[receiver_index]:
        return
    
    receiver_gene = receiver[receiver_index]
    donor_gene = donor[donor_index]
    if is_input_gene(receiver_gene) or is_input_gene(donor_gene):
        return
    
    if is_output_gene(receiver_gene):
        if is_output_gene(donor_gene):
            exchange(receiver=receiver,
                        receiver_flags=receiver_flags,
                        receiver_index=receiver_gene[1],
                        donor=donor,
                        donor_index=donor_gene[1],
                        exchange_rate=exchange_rate,
                        nrows=nrows)
            return
        else:
            raise Exception(&#34;output gene mismatch in subgraph exchange&#34;)
        
    next_receiver_genes = []
    next_donor_genes = []
    for i in range(1, len(receiver_gene)):
        if receiver_gene[i] != -1 and donor_gene[i] != -1 and random_bool(exchange_rate):
            next_receiver_genes.append(receiver_gene[i])
            next_donor_genes.append(donor_gene[i])
    
    format_inputs_for_new_operation(receiver[receiver_index], receiver_index, donor_gene[0], nrows)
    receiver_gene[0] = donor_gene[0]
    receiver_flags[receiver_index] = True

    for i in range(len(next_receiver_genes)):
        exchange(receiver=receiver,
                    receiver_flags=receiver_flags,
                    receiver_index=next_receiver_genes[i],
                    donor=donor,
                    donor_index=next_donor_genes[i],
                    exchange_rate=exchange_rate,
                    nrows=nrows)</code></pre>
</details>
</dd>
<dt id="genome.format_inputs_for_new_operation"><code class="name flex">
<span>def <span class="ident">format_inputs_for_new_operation</span></span>(<span>gene, gene_index, new_operation, nrows)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Prepares the given gene for a change of operation allele, by changing the inputs to match the new operation.
Shortened inputs are set to -1, if a new input is needed, it is set to a random (in bounds) value.</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>gene<ul>
<li>gene to prepare inputs for</li>
</ul>
</li>
<li>gene_index<ul>
<li>index of the gene to prepare in given genome</li>
</ul>
</li>
<li>operation<ul>
<li>new operation to be inside gene</li>
</ul>
</li>
<li>nrows<ul>
<li>number of rows in the matrix of genes</li>
</ul>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_inputs_for_new_operation(gene, gene_index, new_operation, nrows):
    &#39;&#39;&#39;[summary]
    Prepares the given gene for a change of operation allele, by changing the inputs to match the new operation.
    Shortened inputs are set to -1, if a new input is needed, it is set to a random (in bounds) value.
    ### Parameters
    1. gene
        - gene to prepare inputs for
    2. gene_index
        - index of the gene to prepare in given genome
    3. operation
        - new operation to be inside gene
    4. nrows
        - number of rows in the matrix of genes
    &#39;&#39;&#39;
    ncolumns = len(gene) / nrows
    operation_inputs = get_number_of_op_inputs(new_operation)
    for input_number in range(1, len(gene)):
        if input_number &lt;= operation_inputs and gene[input_number] == -1:
            gene[input_number] = np.random.randint(get_last_possible_input_index(ncolumns, nrows, gene_index))
        elif input_number &gt; operation_inputs and gene[input_number] != -1:
            gene[input_number] = -1</code></pre>
</details>
</dd>
<dt id="genome.genome_output"><code class="name flex">
<span>def <span class="ident">genome_output</span></span>(<span>genome, active_gene_indexes, input_matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>genome<ul>
<li>genome to calculate output for</li>
</ul>
</li>
<li>input_matrix<ul>
<li>list of input values to calculate output for</li>
<li>each list of input values is one input</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>np.ndarray
- output of genome for given input values
- works with only one output gene (TODO if necessary)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def genome_output(genome, active_gene_indexes, input_matrix):
    &#39;&#39;&#39;[summary]
    ### Parameters
    1. genome
        - genome to calculate output for
    2. input_matrix
        - list of input values to calculate output for
        - each list of input values is one input

    ### Returns
    np.ndarray
        - output of genome for given input values
        - works with only one output gene (TODO if necessary)
    &#39;&#39;&#39;
    n_input_nodes = len(input_matrix) # gen number of input nodes, base on parameter input_matrix
    nrows = len(active_gene_indexes) + n_input_nodes # number of rows in matrix
    ncols = len(input_matrix[0]) # number of columns in matrix

    # mapping from gene index to matrix index, so we can use gene indexes to access the matrix, and the matrix can be only as big as the number of active nodes
    gene_to_matrix_mapping = {key: value for key, value in zip(active_gene_indexes[::-1], range(n_input_nodes, nrows))}

    matrix = np.full((nrows, ncols), 0.0)

    # fill the matrix with input values
    for i in range(n_input_nodes):
        matrix[i] = input_matrix[i]
        gene_to_matrix_mapping[i] = i

    # fill the matrix with output of genes
    for i in range(len(active_gene_indexes)):
        for gene_index in active_gene_indexes:
            gene = genome[gene_index]
            gene_operation = gene[0]

            # in case of input gene, skip it
            if (gene_operation == -1):
                continue

            # in case of output gene, copy the input gene output
            if (gene_operation == -2):
                last_function_gene_index = gene[1]
                matrix[gene_to_matrix_mapping[gene_index]] = matrix[gene_to_matrix_mapping[last_function_gene_index]]
                continue

            # function genes
            n_of_op_inputs = op_inputs[operations[gene_operation]]
            op_function = op_functions[operations[gene_operation]]

            if n_of_op_inputs == 1:
                first_input = matrix[gene_to_matrix_mapping[gene[1]]]
                matrix[gene_to_matrix_mapping[gene_index]] = op_function(first_input)
            elif n_of_op_inputs == 2:
                first_input = matrix[gene_to_matrix_mapping[gene[1]]]
                second_input = matrix[gene_to_matrix_mapping[gene[2]]]
                matrix[gene_to_matrix_mapping[gene_index]] = op_function(first_input, second_input) # calculate the output of the gene

    # return the last column (output column) of the matrix
    return matrix[-1]</code></pre>
</details>
</dd>
<dt id="genome.is_acceptable_solution"><code class="name flex">
<span>def <span class="ident">is_acceptable_solution</span></span>(<span>output, wanted_output, max_difference)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Returns True if the difference between output and wanted_output is less than max_difference, False otherwise</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>output<ul>
<li>output to compare</li>
</ul>
</li>
<li>wanted_output<ul>
<li>wanted output to compare</li>
</ul>
</li>
<li>max_difference<ul>
<li>maximum difference between output and wanted_output</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>bool
- True if the difference between output and wanted_output is less than max_difference, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_acceptable_solution(output, wanted_output, max_difference):
    &#39;&#39;&#39;[summary]
    Returns True if the difference between output and wanted_output is less than max_difference, False otherwise
    ### Parameters
    1. output
        - output to compare
    2. wanted_output
        - wanted output to compare
    3. max_difference
        - maximum difference between output and wanted_output
    ### Returns
    bool
        - True if the difference between output and wanted_output is less than max_difference, False otherwise
    &#39;&#39;&#39;
    return np.absolute(np.subtract(wanted_output, output)).max() &lt;= max_difference</code></pre>
</details>
</dd>
<dt id="genome.mutate_gene"><code class="name flex">
<span>def <span class="ident">mutate_gene</span></span>(<span>gene, gene_index, ncolumns, nrows)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Returns mutated gene (may mutate the original)</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>gene<ul>
<li>gene to mutate</li>
</ul>
</li>
<li>gene_index<ul>
<li>index of the gene in the genome</li>
</ul>
</li>
<li>ncolumns<ul>
<li>number of columns in the matrix of genes</li>
</ul>
</li>
<li>nrows<ul>
<li>number of rows in the matrix of genes</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>List[int]
- mutated gene
bool
- True if gene was successfully mutated, False otherwise
Raises</p>
<hr>
<ul>
<li>Exception<ul>
<li>if last_possible_input_index is 0, meaning that an internal error occured</li>
</ul>
</li>
</ul>
<h3 id="_1"></h3></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutate_gene(gene, gene_index, ncolumns, nrows):
    &#39;&#39;&#39;[summary]
    Returns mutated gene (may mutate the original)
    ### Parameters
    1. gene
        - gene to mutate
    2. gene_index
        - index of the gene in the genome
    3. ncolumns
        - number of columns in the matrix of genes
    4. nrows
        - number of rows in the matrix of genes
    ### Returns
    List[int]
        - mutated gene
    bool
        - True if gene was successfully mutated, False otherwise
    Raises
    ------
    - Exception
        - if last_possible_input_index is 0, meaning that an internal error occured
    ### 
    &#39;&#39;&#39;
    allele_to_mutate = np.random.randint(0, len(gene))

    if gene[allele_to_mutate] == -1 or gene[allele_to_mutate] == -2:
        return gene, False

    mutation_to_be_done = True
    while(mutation_to_be_done):
        original = gene[allele_to_mutate]

        # if the gene is an operation, mutate it to another operation
        if allele_to_mutate == 0:
            mutated = np.random.randint(0, len(operations))
        # if the gene is an input, mutate it to another (correct) input
        else:
            last_possible_input_index = get_last_possible_input_index(ncolumns, nrows, gene_index)
            if (last_possible_input_index &lt;= 0):
                raise Exception(f&#34;last_possible_input_index is: {last_possible_input_index}, gene_index is: {gene_index}, ncolumns is: {ncolumns}, nrows is: {nrows}&#34;)
            elif (last_possible_input_index == 1):
                return gene, False # impossible to mutate input, if there is only one option available

            mutated = np.random.randint(0, last_possible_input_index)

        # if the gene was successfully mutated, stop the loop
        if original != mutated:
            # in case the mutation is changing the operation, prepare the inputs for the new operation
            if allele_to_mutate == 0:
                format_inputs_for_new_operation(gene, gene_index, mutated, nrows)
            gene[allele_to_mutate] = mutated
            mutation_to_be_done = False

    return gene, True</code></pre>
</details>
</dd>
<dt id="genome.mutate_individual"><code class="name flex">
<span>def <span class="ident">mutate_individual</span></span>(<span>target, ncolumns, nrows, mutation_rate)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Returns mutated individual, without changing the original</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>target<ul>
<li>individual to mutate</li>
</ul>
</li>
<li>ncolumns<ul>
<li>number of columns in the matrix of genes</li>
</ul>
</li>
<li>nrows<ul>
<li>number of rows in the matrix of genes</li>
</ul>
</li>
<li>mutation_rate<ul>
<li>mutation rate of the algorithm</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>List[List[int]]
- mutated individual</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutate_individual(target, ncolumns, nrows, mutation_rate):
    &#39;&#39;&#39;[summary]
    Returns mutated individual, without changing the original
    ### Parameters
    1. target
        - individual to mutate
    2. ncolumns
        - number of columns in the matrix of genes
    3. nrows
        - number of rows in the matrix of genes
    4. mutation_rate
        - mutation rate of the algorithm
    ### Returns
    List[List[int]]
        - mutated individual
    &#39;&#39;&#39;
    # deep copy the target, so we don&#39;t change the original
    individual = deepcopy(target)
    genome_length = len(individual)
    n_of_genes_to_mutate = floor(genome_length * mutation_rate + 1)

    for i in range(n_of_genes_to_mutate):
        success = False
        mutated_gene = []

        # find a gene that can be mutated
        while(not success):
            gene_index_to_mutate = np.random.randint(genome_length)
            gene = individual[gene_index_to_mutate]
            mutated_gene, success = mutate_gene(gene, gene_index_to_mutate, ncolumns, nrows)

        individual[gene_index_to_mutate] = mutated_gene

    return individual</code></pre>
</details>
</dd>
<dt id="genome.subgraph_exchange"><code class="name flex">
<span>def <span class="ident">subgraph_exchange</span></span>(<span>receiver, receiver_active_path, donor, donor_active_path, exchange_rate, nrows)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]
Returns child genome from two parent genomes using recombination 2</p>
<h3 id="parameters">Parameters</h3>
<ol>
<li>parent1<ul>
<li>first parent genome</li>
</ul>
</li>
<li>parent2<ul>
<li>second parent genome</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>List[List[int]]
- child genome</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subgraph_exchange(receiver, receiver_active_path, donor, donor_active_path, exchange_rate, nrows):
    &#39;&#39;&#39;[summary]
    Returns child genome from two parent genomes using recombination 2
    ### Parameters
    1. parent1
        - first parent genome
    2. parent2
        - second parent genome
    ### Returns
    List[List[int]]
        - child genome
    &#39;&#39;&#39;

    # deep copy the parents, so we don&#39;t change the original
    child = deepcopy(receiver)

    possible_exchange_indexes = [gene for gene in receiver_active_path if gene in donor_active_path]
    exchange_index = np.random.choice(possible_exchange_indexes)

    receiver_flags = [False for _ in range(len(receiver))]
    exchange(receiver=child, receiver_flags=receiver_flags, receiver_index=exchange_index, donor=donor, donor_index=exchange_index, exchange_rate=exchange_rate, nrows=nrows)
    return child</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="genome.active_gene_transplant" href="#genome.active_gene_transplant">active_gene_transplant</a></code></li>
<li><code><a title="genome.evaluate_fitness" href="#genome.evaluate_fitness">evaluate_fitness</a></code></li>
<li><code><a title="genome.exchange" href="#genome.exchange">exchange</a></code></li>
<li><code><a title="genome.format_inputs_for_new_operation" href="#genome.format_inputs_for_new_operation">format_inputs_for_new_operation</a></code></li>
<li><code><a title="genome.genome_output" href="#genome.genome_output">genome_output</a></code></li>
<li><code><a title="genome.is_acceptable_solution" href="#genome.is_acceptable_solution">is_acceptable_solution</a></code></li>
<li><code><a title="genome.mutate_gene" href="#genome.mutate_gene">mutate_gene</a></code></li>
<li><code><a title="genome.mutate_individual" href="#genome.mutate_individual">mutate_individual</a></code></li>
<li><code><a title="genome.subgraph_exchange" href="#genome.subgraph_exchange">subgraph_exchange</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>